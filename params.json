{"name":"Node-orch","tagline":"Orch.js: Distributed RCP Orchestration Library for Node.js","body":"## Orch.js\r\n\r\nOrch.js: RCP Orchestration Library (or the bastard son of Delayed Jobs and RCP).\r\n\r\n### Features\r\n\r\n* Request/Reply RPC\r\n* Durable tasks\r\n* Fire & Forget operations\r\n* Dynamic Workflow-like execution\r\n* Nested calls and Callbacks\r\n* Error Handling / Retry Support\r\n* Granular Scaling\r\n* AMQP Support (RabbitMQ)\r\n\r\n### How it Works\r\n\r\n* A JSON document called _task_ contains an stack of actions to be performed. The initial task only contain one or two actions. Other actions can be added dynamically by the execution of initial seed of actions.\r\n* Every action generates a result that will be used as the input of the next action creating a simple but effective workflow-like orchestration of operations until there is no action to perform in the task.\r\n* Queues matching the name of the next action will hold the task to be executed, a worker will listen to the queue and pick up the task as they arrive and perform one action, enqueue the task again in the same queue (recursion/loops) or post it in another queue(continuation).\r\n* Workers can implement all or a partial set of actions, allowing granular scaling without hassle.\r\n\r\nThe decoupled nature of Orch.js will enable the implementation in other Programming Languages in the future, allowing the creation of distributed polyglot applications.\r\n\r\n### Installation\r\n\r\n    $ npm install orch orch-amqp\r\n\r\n### Usage\r\n\r\nThe next examples assume you are using [orch-amqp](https://github.com/bithavoc/node-orch-amqp) and [RabbitMQ](http://www.rabbitmq.com/).\r\n\r\n#### Client: Creating Tasks\r\n\r\nIn order to run operations, you need to use a Client. The client will create the tasks for you. \r\n\r\nThe following example shows how to start a task with two initial actions. It will perform 'generate_message' followed by 'print':\r\n\r\n\t// Generate a Message and then Print it.\r\n\tclient.run('generate_message', {\r\n\t\tmessage: \"Hello %s\",\r\n\t\tname: \"John Doe\"\r\n\t}, 'print'); // The result of 'generate_message' will be the input of 'print'.\r\n\r\nSee full source code at: [examples/hello\\_world\\_client.js](https://github.com/bithavoc/node-orch/blob/master/examples/hello_world_client.js)\r\n\r\n*print* doesn't need an input. the result of 'generate_message' will be input in the future.\r\n\r\nOnce you run the client app, you will see how Orch.js prepared all the necessary queues and posted the task.\r\n\r\n![generate_message queue in rabbitmq](https://raw.github.com/bithavoc/node-orch/master/examples/images/generate_message_queue_list.png)\r\n\r\nOrch will create durable queues, even if you restart RabbitMQ you will still have your messages waiting to be processed any worker that implements the operation.\r\n\r\nNow we need to implement the operations.\r\n\r\n#### Workers: Implementing Operations\r\n\r\nOperations are implemented as functions along with the action to respond. Each worker can implement one or more actions.\r\n\r\n**Worker #0**. This worker implements the operation *generate_message*:\r\n\r\n\tworker.register('generate_message', function generateMessage(context) {\r\n\t  console.log(\"(Worker: Processing generate_message)\");\r\n\t  context.success({\r\n\t    msg: util.format(context.input.message, context.input.name)\r\n\t  }, 'SUCCESS', 'Message has been generated');\r\n\t});\r\n\r\nSee full source code at: [examples/hello\\_world\\_generate\\_message.js](https://github.com/bithavoc/node-orch/blob/master/examples/hello_world_generate_message.js)\r\n\r\nOnce you run this worker, you will see how another queue was created to hold the task now needing to perform the print.\r\n\r\n![print queue in rabbitmq](https://raw.github.com/bithavoc/node-orch/master/examples/images/print_queues_list.png)\r\n\r\n**Worker #1**: This worker implements the operation *print*:\r\n\r\n\tworker.register('print', function print(context) {\r\n\t  console.log(\"(Worker: Processing print)\");\r\n\t  console.log(\"Print: %s\", context.input.msg);\r\n\t  context.success(null, 'SUCCESS', 'Message has been printed');\r\n\t});\r\n\r\nSee full source code at: [examples/hello\\_world\\_print.js](https://github.com/bithavoc/node-orch/blob/master/examples/hello_world_print.js)\r\n\r\nOnce you run this second worker, the last action of the task is completed and the task is considered done.\r\n\r\n![queues empty in rabbitmq](https://raw.github.com/bithavoc/node-orch/master/examples/images/print_empty.png)\r\n\r\nThe output for the second worker would be:\r\n\r\n    (Worker: Processing print)\r\n    Print: Hello John Doe\r\n\r\nOf course this is just an example, nothing this simple requires such distributed execution, Orch.js is intended to be used for distribution of heavy/cpu-bound operations that should not be performed in the main web server.\r\n\r\n#### Callbacks and Deferred Results\r\nAn operation may often run nested actions before providing a final result, this is called deferred results. Callbacks receive the result of the nested operation and then provide the final result for the main operation.\r\n\r\nExample: Because string formatting is an operation that can be reused easily, with the help of callbacks we can refactor our Hello World to as follows:\r\n\r\n    -> generate_message\t\t\t\t// defer the result to format_string\r\n       -> format_string\t\t\t\t// nested call\r\n\t-> generate_message#formatted\t// callback generates deferred result\r\n\t-> print\t\t\t\t\t\t// receives deferred result\r\n\r\nThis is how we implement it:\r\n\r\n\t// Operation: generate_message\r\n\tvar generateMessage = worker.register('generate_message', function generateMessage(context) {\r\n\t  console.log(\"(Worker: Processing generate_message)\");\r\n\t  context.defer('format_string', {\r\n\t    format: context.input.message,\r\n\t    value: context.input.name\r\n\t  }, 'formatted');\r\n\t});\r\n\r\n\t// Callback: generate_message#formatted\r\n\tgenerateMessage.callback('formatted', function formatted(context) {\r\n\t  context.success({\r\n\t    msg: context.result.str\r\n\t  }, 'SUCCESS', 'Message has been generated');\r\n\t});\r\n\r\n\t// Operation: format_string\r\n\tworker.register('format_string', function formatString(context) {\r\n\t  console.log(\"(Worker: Processing format_string)\");\r\n\t  context.success({\r\n\t    str: util.format(context.input.format, context.input.value)\r\n\t  }, 'SUCCESS', 'Message has been formatted');\r\n\t});\r\n\r\n\t// Operation: print\r\n\tworker.register('print', function print(context) {\r\n\t  console.log(\"(Worker: Processing print)\");\r\n\t  console.log(\"Print: %s\", context.input.msg);\r\n\t  context.success(null, 'SUCCESS', '');\r\n\t});\r\n\r\n\r\nSee full source code at: [examples/deferred\\_worker.js](https://github.com/bithavoc/node-orch/blob/master/examples/deferred_worker.js)\r\n\r\nWorker Output:\r\n\r\n\t(Worker: Processing generate_message)\r\n\t(Worker: Processing format_string)\r\n\t(Worker: Processing print)\r\n\tPrint: Hello John Doe\r\n\r\n#### Error Handling\r\n\r\nYou can use `context.fail` to immediately report errors as result.\r\n\r\n\t// Callback: generate_message#formatted\r\n\tgenerateMessage.callback('formatted', function formatted(context) {\r\n\t  if (context.status.code != 'SUCCESS') {\r\n\t    // here we handle the error of 'format_string'.\r\n\t    return context.success({\r\n\t      msg: \"Houston, Internal Application Error!\"\r\n\t    }, 'ERROR', \"Some error came up\");\r\n\t  }\r\n\t  context.complete({\r\n\t    msg: context.result.str\r\n\t  });\r\n\t});\r\n\r\n\t// Operation: format_string\r\n\tworker.register('format_string', function formatString(context) {\r\n\t  console.log(\"(Worker: Processing format_string)\");\r\n\t  if (!context.input.format) {\r\n\t    return context.retry(new Error('The format string is not valid'), 'INVALID_FORMAT_STRING');\r\n\t  }\r\n\t  context.complete({\r\n\t    str: util.format(context.input.format, context.input.value)\r\n\t  });\r\n\t});\r\n\r\nSee full source code at: [examples/errors\\_worker.js](https://github.com/bithavoc/node-orch/blob/master/examples/errors_worker.js)\r\n\r\nWorker output:\r\n\r\n\t(Worker: Processing generate_message)\r\n\t(Worker: Processing format_string)\r\n\t(Worker: Processing print)\r\n\tPrint: Houston, Internal Application Error!\r\n\r\nThe error structure contains:\r\n\r\n* msg (String)\r\n* stack (String)\r\n* code (String)\r\n\r\n**Note:** All operations can receive errors instead of a regular input, however, error handling only makes sense inside callbacks.\r\n\r\n#### Error Retry\r\n\r\nSome of errors are caused due unavailability of external resources and can be retried later when they are available. To specify the number of times you want to retry in case of certain error, you can use `ActionMeta.retry` at the moment you register the operation and `context.retry` in the implementation of the action:\r\n\r\n\t// Operation: format_string\r\n\tworker.register('format_string', function formatString(context) {\r\n\t  console.log(\"(Worker: Processing format_string)\");\r\n\t  if (!context.input.format) {\r\n\t    return context.retry(new Error('The format string is not valid'), 'INVALID_FORMAT_STRING');\r\n\t  }\r\n\t  context.complete({\r\n\t    str: util.format(context.input.format, context.input.value)\r\n\t  });\r\n\t}).retry('INVALID_FORMAT_STRING', 3);\r\n\r\nWhen the retry limit is reached, `context.fail` will be called for you.\r\n\r\nSee full source code at: [examples/retry\\_worker.js](https://github.com/bithavoc/node-orch/blob/master/examples/retry_worker.js)\r\n\r\nWorker output:\r\n\r\n\t(Worker: Processing generate_message)\r\n\t(Worker: Processing format_string)\r\n\t(Worker: Processing format_string)\r\n\t(Worker: Processing format_string)\r\n\t(Worker: Processing print)\r\n\tPrint: Houston, Internal Application Error!\r\n\r\n#### Sharing variables between Callbacks\r\n\r\n`contexts.vars` is the dictionary containing all the values shared between the main operation and the callbacks. Since the implementation function is bound to `context.vars`, you can also use `this` to set whatever variable you need.\r\n\r\n\t...\r\n\t// Operation: generate_message\r\n\tvar generateMessage = worker.register('generate_message', function generateMessage(context) {\r\n\t  // set variable req_time, we will use it in the callbacks.\r\n\t  this.req_time = new Date().toString();\r\n\t  console.log(\"(Worker: Processing generate_message)\");\r\n\t  context.defer('format_string', {\r\n\t    format: context.input.message,\r\n\t    value: context.input.name\r\n\t  }, 'formatted');\r\n\t})\r\n\t...\r\n\t// Callback: generate_message#formatted\r\n\tgenerateMessage.callback('formatted', function(context) {\r\n\t  // here we use the variable req_time\r\n\t  context.success({\r\n\t    msg: context.result.str + \" \" + this.req_time\r\n\t  }, 'SUCCESS', 'Completed!');\r\n\t});\r\n\r\nJust like inputs and results, the variables need to be JSON friendly since they are serialized within the task document.\r\n\r\n#### Performing Distributed RPC Calls\r\n\r\nYou can wait for a task to complete and get the results by performing the task in RPC mode.\r\n\r\n\t...\r\n\tclient.enableRpc = true;\r\n\t...\r\n\t// Generate a Message and then Print it.\r\n\tclient.rpc('generate_message', {\r\n\t    message: \"Hello %s\",\r\n\t    name: \"John Doe\"\r\n\t  }, function rpcCompleted(err, context) {\r\n\t  assert.ifError(err);\r\n\t  console.log(\"Result\", context.result);\r\n\t});\r\n\r\n\r\n### Tests\r\n\r\n    npm test\r\n\r\n### What's next? (TODO)\r\n\r\n* Logging. A separate queue fed by AMQP Fanout exchange with bindings for all actions.\r\n* Using the same logging mechanism, create a CLI tool to see the progress of a task across the queues. Breakpoints can be implemented as a pseudo-worker that takes the message without doing any ACK. We might need modify the specification to add a *taskId* property.\r\n\r\n## License (MIT)\r\n\r\nCopyright (c) 2012-2014 Bithavoc.com -  http://bithavoc.io\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}